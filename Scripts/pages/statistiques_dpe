import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import folium
from streamlit_folium import st_folium
from pyproj import Transformer
from functools import lru_cache

#  OPTIMISATION : Cache pour charger les donn√©es UNE SEULE FOIS
@st.cache_data(ttl=3600)
def load_data():
    """Charge et pr√©pare les donn√©es une seule fois"""
    csv_path = r"C:\Users\perri\Documents\MASTER SISE\Cours\Machine Learning sous Python\dpe-v2-logements-existants.csv"
    
    # Chargement avec colonnes sp√©cifiques seulement (plus rapide)
    cols_needed = [
        "Code_postal_(BAN)", "Type_b√¢timent", "Type_√©nergie_principale_chauffage",
        "Type_√©nergie_principale_ECS", "P√©riode_construction", "Surface_habitable_logement",
        "Conso_5_usages_√©_finale", "Conso_chauffage_√©_finale", "Conso_ECS_√©_finale",
        "Ann√©e_construction", "Typologie_logement", "Etiquette_DPE", "Etiquette_GES",
        "Conso_5_usages_par_m¬≤_√©_primaire", "Emission_GES_5_usages_par_m¬≤",
        "Type_installation_chauffage", "Type_installation_ECS_(g√©n√©ral)",
        "Co√ªt_total_5_usages", "Co√ªt_chauffage", "Co√ªt_ECS", "Co√ªt_√©clairage",
        "Ubat_W/m¬≤_K", "Qualit√©_isolation_enveloppe", "Qualit√©_isolation_menuiseries",
        "Qualit√©_isolation_murs", "Isolation_toiture_(0/1)", "Indicateur_confort_√©t√©",
        "Logement_traversant_(0/1)", "Coordonn√©e_cartographique_X_(BAN)",
        "Coordonn√©e_cartographique_Y_(BAN)", "Nom__commune_(BAN)"
    ]
    
    df = pd.read_csv(csv_path, sep=',', encoding='utf-8', low_memory=False, usecols=cols_needed)
    
    # Conversion en num√©rique
    numeric_cols = ["Conso_5_usages_√©_finale", "Conso_chauffage_√©_finale", "Conso_ECS_√©_finale"]
    for col in numeric_cols:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    
    # Nettoyage code postal
    df['Code_postal_(BAN)'] = (
        df['Code_postal_(BAN)']
        .astype(str)
        .str.replace(r'\.0$', '', regex=True)
        .str.strip()
    )
    df = df[df['Code_postal_(BAN)'].notna() & (df['Code_postal_(BAN)'] != 'nan') & (df['Code_postal_(BAN)'] != '')]
    
    return df

@st.cache_data(ttl=3600)
def prepare_map_data(df):
    """Pr√©pare les donn√©es cartographiques (conversion coordonn√©es)"""
    transformer = Transformer.from_crs("EPSG:2154", "EPSG:4326", always_xy=True)
    
    # Conversion des coordonn√©es
    df_map = df.dropna(subset=['Coordonn√©e_cartographique_X_(BAN)', 'Coordonn√©e_cartographique_Y_(BAN)']).copy()
    df_map['lon'], df_map['lat'] = transformer.transform(
        df_map['Coordonn√©e_cartographique_X_(BAN)'].values,
        df_map['Coordonn√©e_cartographique_Y_(BAN)'].values
    )
    
    # Nettoyage coordonn√©es
    df_map = df_map[(df_map['lat'].between(41, 51)) & (df_map['lon'].between(-5, 10))]
    
    # Limiter √† 50 000 points max pour performances
    if len(df_map) > 50_000:
        df_map = df_map.sample(50_000, random_state=42)
    
    return df_map


def show():
        
    # Chargement des donn√©es avec spinner moderne
    with st.spinner('üîÑ Chargement des donn√©es...'):
        df = load_data()
    
    # --- Cr√©ation des sous-onglets ---
    tab_stats, tab_graphs, tab_map = st.tabs([" Statistiques", " Graphiques", " Cartographie"])

    # === ONGLET 1 : STATISTIQUES ===
    with tab_stats:

        st.markdown('<p class="section-title"> Filtrer les donn√©es</p>', unsafe_allow_html=True)

        # --- FILTRES COMPACTS ---
        col1, col2, col3 = st.columns(3)
        with col1:
            selected_codes_postaux = st.multiselect(" Code postal", 
                options=sorted(df['Code_postal_(BAN)'].dropna().unique()), key="cp_stats")
        with col2:
            selected_types_batiment = st.multiselect(" Type de b√¢timent", 
                options=sorted(df['Type_b√¢timent'].dropna().unique()), key="bat_stats")
        with col3:
            selected_periodes = st.multiselect(" P√©riode construction", 
                options=sorted(df['P√©riode_construction'].dropna().unique()), key="per_stats")

        col4, col5 = st.columns(2)
        with col4:
            selected_types_energie = st.multiselect(" √ânergie chauffage", 
                options=sorted(df['Type_√©nergie_principale_chauffage'].dropna().unique()), key="ener_stats")
        with col5:
            selected_types_energie_ecs = st.multiselect(" √ânergie ECS", 
                options=sorted(df['Type_√©nergie_principale_ECS'].dropna().unique()), key="ecs_stats")

        min_surface = int(df['Surface_habitable_logement'].min())
        max_surface = int(df['Surface_habitable_logement'].max())
        selected_surface = st.slider(" Surface habitable (m¬≤)", min_value=min_surface, 
            max_value=max_surface, value=(min_surface, max_surface), key="surf_stats")

        # --- APPLICATION DES FILTRES ---
        filtered_df = df.copy()
        if selected_codes_postaux:
            filtered_df = filtered_df[filtered_df['Code_postal_(BAN)'].isin(selected_codes_postaux)]
        if selected_types_batiment:
            filtered_df = filtered_df[filtered_df['Type_b√¢timent'].isin(selected_types_batiment)]
        if selected_types_energie:
            filtered_df = filtered_df[filtered_df['Type_√©nergie_principale_chauffage'].isin(selected_types_energie)]
        if selected_types_energie_ecs:
            filtered_df = filtered_df[filtered_df['Type_√©nergie_principale_ECS'].isin(selected_types_energie_ecs)]
        if selected_periodes:
            filtered_df = filtered_df[filtered_df['P√©riode_construction'].isin(selected_periodes)]
        filtered_df = filtered_df[
            (filtered_df['Surface_habitable_logement'] >= selected_surface[0]) &
            (filtered_df['Surface_habitable_logement'] <= selected_surface[1])
        ]

        st.markdown("---")
        st.markdown('<p class="section-title"> R√©sultats</p>', unsafe_allow_html=True)

        # --- CALCUL STATISTIQUES ---
        conso_cols = {
            " Consommation totale": ("Conso_5_usages_√©_finale", "kWh/an"),
            " Consommation chauffage": ("Conso_chauffage_√©_finale", "kWh/an"),
            " Consommation eau chaude": ("Conso_ECS_√©_finale", "kWh/an")
        }

        if filtered_df.empty:
            st.warning("‚ö†Ô∏è Aucune donn√©e ne correspond aux filtres s√©lectionn√©s.")
        else:
            cols = st.columns(3)
            for col, (label, (col_name, unit)) in zip(cols, conso_cols.items()):
                if col_name in filtered_df.columns and not filtered_df[col_name].dropna().empty:
                    mean_val = filtered_df[col_name].mean()
                    std_val = filtered_df[col_name].std()
                    min_val = filtered_df[col_name].min()
                    max_val = filtered_df[col_name].max()
                    
                    col.markdown(f"""
                    <div class="metric-modern">
                        <h4>{label}</h4>
                        <div style="font-size: 0.9rem; color: #666; margin-bottom: 8px; font-weight: 600;">Moyenne</div>
                        <div class="metric-value">{mean_val:,.0f} {unit}</div>
                        <div class="metric-detail"> √âcart-type: {std_val:,.0f} {unit}</div>
                        <div class="metric-detail"> Min: {min_val:,.0f} {unit} |  Max: {max_val:,.0f} {unit}</div>
                    </div>
                    """, unsafe_allow_html=True)

    # === ONGLET 2 : GRAPHIQUES ===
    with tab_graphs:
        st.markdown('<p class="section-title"> Visualisation graphique interactive</p>', unsafe_allow_html=True)

        # --- Colonnes et noms ---
        colonnes_disponibles = [
            "Ann√©e_construction", "Type_b√¢timent", "Typologie_logement",
            "Surface_habitable_logement", "Etiquette_DPE", "Etiquette_GES",
            "Conso_5_usages_par_m¬≤_√©_primaire", "Conso_5_usages_√©_finale",
            "Emission_GES_5_usages_par_m¬≤", "Conso_chauffage_√©_finale",
            "Conso_ECS_√©_finale", "Type_√©nergie_principale_chauffage",
            "Type_√©nergie_principale_ECS", "Type_installation_chauffage",
            "Type_installation_ECS_(g√©n√©ral)", "Co√ªt_total_5_usages", 
            "Co√ªt_chauffage", "Co√ªt_ECS", "Co√ªt_√©clairage",
            "Ubat_W/m¬≤_K", "Qualit√©_isolation_enveloppe", 
            "Qualit√©_isolation_menuiseries", "Qualit√©_isolation_murs",
            "Isolation_toiture_(0/1)", "Indicateur_confort_√©t√©",
            "Logement_traversant_(0/1)"
        ]

        noms_affiches = {
            "Ann√©e_construction": "Ann√©e de construction",
            "Type_b√¢timent": "Type de b√¢timent",
            "Typologie_logement": "Typologie du logement",
            "Surface_habitable_logement": "Surface habitable (m¬≤)",
            "Etiquette_DPE": "√âtiquette DPE",
            "Etiquette_GES": "√âtiquette GES",
            "Conso_5_usages_par_m¬≤_√©_primaire": "Conso √©nergie primaire (kWh/m¬≤.an)",
            "Conso_5_usages_√©_finale": "Conso totale √©nergie finale (kWh/an)",
            "Emission_GES_5_usages_par_m¬≤": "√âmissions CO‚ÇÇ (kgCO‚ÇÇ/m¬≤.an)",
            "Conso_chauffage_√©_finale": "Conso chauffage (kWh/an)",
            "Conso_ECS_√©_finale": "Conso eau chaude (kWh/an)",
            "Type_√©nergie_principale_chauffage": "Type d'√©nergie principale chauffage",
            "Type_√©nergie_principale_ECS": "Type d'√©nergie principale ECS",
            "Type_installation_chauffage": "Type d'installation chauffage",
            "Type_installation_ECS_(g√©n√©ral)": "Type d'installation ECS",
            "Co√ªt_total_5_usages": "Co√ªt total √©nergie (‚Ç¨)",
            "Co√ªt_chauffage": "Co√ªt chauffage (‚Ç¨)",
            "Co√ªt_ECS": "Co√ªt ECS (‚Ç¨)",
            "Co√ªt_√©clairage": "Co√ªt √©clairage (‚Ç¨)",
            "Ubat_W/m¬≤_K": "D√©perdition thermique (Ubat W/m¬≤.K)",
            "Qualit√©_isolation_enveloppe": "Qualit√© isolation enveloppe",
            "Qualit√©_isolation_menuiseries": "Qualit√© isolation menuiseries",
            "Qualit√©_isolation_murs": "Qualit√© isolation murs",
            "Isolation_toiture_(0/1)": "Isolation toiture",
            "Indicateur_confort_√©t√©": "Indicateur confort √©t√©",
            "Logement_traversant_(0/1)": "Logement traversant"
        }

        # Palette moderne
        palette = ["#097536", "#4CAF50", "#81C784", "#A5D6A7", "#C8E6C9"]

        col1, col2 = st.columns([1, 2])
        with col1:
            type_graphique = st.selectbox(" Type de graphique", 
                ["Histogramme", "Nuage de points", "Boxplot", "Diagramme circulaire"])
        
        with col2:
            if type_graphique == "Nuage de points":
                subcol1, subcol2 = st.columns(2)
                with subcol1:
                    valeur_x = st.selectbox("Axe X", options=colonnes_disponibles,
                        format_func=lambda x: noms_affiches.get(x, x), key="x_graph")
                with subcol2:
                    colonnes_y = [c for c in colonnes_disponibles if c != valeur_x]
                    valeur_y = st.selectbox("Axe Y", options=colonnes_y,
                        format_func=lambda x: noms_affiches.get(x, x), key="y_graph")
            else:
                valeur_x = st.selectbox("Variable", options=colonnes_disponibles,
                    format_func=lambda x: noms_affiches.get(x, x), key="var_graph")
                valeur_y = None

        # --- G√©n√©ration graphique ---
        if valeur_x:
            data = df[[valeur_x]].dropna() if valeur_y is None else df[[valeur_x, valeur_y]].dropna()
            
            # Limiter √† 100k points pour performances
            if len(data) > 100_000:
                data = data.sample(100_000, random_state=42)

            if not data.empty:
                fig = None
                if type_graphique == "Histogramme":
                    fig = px.histogram(
                        data, 
                        x=valeur_x, 
                        nbins=30, 
                        color_discrete_sequence=palette,
                        title=f"Histogramme : {noms_affiches.get(valeur_x, valeur_x)}",
                        labels={valeur_x: noms_affiches.get(valeur_x, valeur_x)}
                    )
                elif type_graphique == "Nuage de points":
                    fig = px.scatter(
                        data, 
                        x=valeur_x, 
                        y=valeur_y, 
                        opacity=0.5, 
                        color_discrete_sequence=palette,
                        title=f"Nuage de points : {noms_affiches.get(valeur_x, valeur_x)} vs {noms_affiches.get(valeur_y, valeur_y)}",
                        labels={
                            valeur_x: noms_affiches.get(valeur_x, valeur_x),
                            valeur_y: noms_affiches.get(valeur_y, valeur_y)
                        }
                    )
                elif type_graphique == "Boxplot":
                    fig = px.box(
                        data, 
                        y=valeur_x, 
                        color_discrete_sequence=palette,
                        title=f"Boxplot : {noms_affiches.get(valeur_x, valeur_x)}",
                        labels={valeur_x: noms_affiches.get(valeur_x, valeur_x)}
                    )
                elif type_graphique == "Diagramme circulaire":
                    counts = data[valeur_x].value_counts().head(8).reset_index()
                    counts.columns = [valeur_x, 'Count']
                    fig = px.pie(
                        counts, 
                        names=valeur_x, 
                        values='Count', 
                        color_discrete_sequence=palette,
                        title=f"R√©partition : {noms_affiches.get(valeur_x, valeur_x)}"
                    )

                fig.update_layout(
                    paper_bgcolor='rgba(0,0,0,0)',
                    plot_bgcolor='rgba(0,0,0,0)',
                    font=dict(color='#094c2e'),
                    margin=dict(l=20, r=20, t=50, b=20),
                    title_x=0.5,
                    title_font=dict(size=18, color='#097536')
                )
                st.plotly_chart(fig, use_container_width=True)

    # === ONGLET 3 : CARTOGRAPHIE ===
    with tab_map:
        st.markdown('<p class="section-title"> Cartographie des logements DPE</p>', unsafe_allow_html=True)

        with st.spinner(' Pr√©paration de la carte...'):
            df_map = prepare_map_data(df)

        etiquettes_dispo = sorted(df_map['Etiquette_DPE'].dropna().unique())
        selected_etiquettes = st.multiselect("üè∑Ô∏è Filtrer par classe √©nerg√©tique :",
            options=etiquettes_dispo, default=etiquettes_dispo[:3], key="map_filter")

        if selected_etiquettes:
            df_filtered = df_map[df_map['Etiquette_DPE'].isin(selected_etiquettes)]
        else:
            df_filtered = df_map.head(10000)  # Limiter si aucun filtre

        color_map = {
            "A": "#007f00", "B": "#4CAF50", "C": "#CDDC39", "D": "#FFEB3B",
            "E": "#FFC107", "F": "#FF5722", "G": "#B71C1C"
        }

        # Conteneur pour √©viter le rechargement complet
        map_container = st.container()
        
        with map_container:
            m = folium.Map(location=[45.75, 4.85], zoom_start=9, tiles="cartodb positron")

            for _, row in df_filtered.iterrows():
                dpe = str(row.get('Etiquette_DPE', 'N/A'))
                tooltip_html = f"""
                    <b>üè∑Ô∏è √âtiquette DPE :</b> {dpe}<br>
                    <b>üè¢ Type b√¢timent :</b> {row.get('Type_b√¢timent', 'N/A')}<br>
                    <b>üìê Surface :</b> {row.get('Surface_habitable_logement', 'N/A')} m¬≤<br>
                    <b>üìÖ Ann√©e construction :</b> {row.get('Ann√©e_construction', 'N/A')}<br>
                    <b>üèòÔ∏è Commune :</b> {row.get('Nom__commune_(BAN)', 'N/A')}<br>
                    <b>‚ö° Conso totale :</b> {row.get('Conso_5_usages_√©_finale', 'N/A')} kWh/an
                """
                folium.CircleMarker(
                    location=[row['lat'], row['lon']],
                    radius=4,
                    color=color_map.get(dpe, "gray"),
                    fill=True,
                    fill_opacity=0.7,
                    tooltip=tooltip_html
                ).add_to(m)

            st_folium(m, width=None, height=600, returned_objects=[])
